generator client {
  provider        = "prisma-client"
  output          = "../src/generated/prisma"
  previewFeatures = ["queryCompiler", "driverAdapters"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                               String                     @id @default(uuid())
  email                            String                     @unique
  createdAt                        DateTime                   @default(now())
  updatedAt                        DateTime                   @updatedAt
  image                            String?
  name                             String?
  role                             String                     @default("CLIENT")
  trainerId                        String?
  featured                         Boolean                    @default(false)
  capacity                         Int?                       // Maximum number of clients trainer can have
  BaseExercise                     BaseExercise[]
  receivedRequests                 CoachingRequest[]          @relation("ReceivedRequests")
  sentRequests                     CoachingRequest[]          @relation("SentRequests")

  exerciseLogs                     ExerciseLog[]
  createdFavouriteWorkouts         FavouriteWorkout[]         @relation("CreatedFavouriteWorkouts")

  mobilePushTokens                 MobilePushToken[]
  createdNotes                     Note[]                     @relation("CreatedNotes")
  createdNotifications             Notification[]             @relation("NotificationCreator")
  notifications                    Notification[]
  pushSubscriptions                PushSubscription[]
  reviews                          Review[]
  assignedPlans                    TrainingPlan[]             @relation("AssignedPlans")
  createdPlans                     TrainingPlan[]             @relation("CreatedPlans")

  trainer                          User?                      @relation("TrainerClients", fields: [trainerId], references: [id])
  clients                          User[]                     @relation("TrainerClients")
  profile                          UserProfile?
  sessions                         UserSession[]

  // Stripe integration
  stripeCustomerId String? @unique
  stripeConnectedAccountId String? @unique  // For trainer revenue sharing

  // Google OAuth integration
  googleId          String? @unique
  googleAccessToken String?
  googleRefreshToken String?
  
  // Apple OAuth integration
  appleId           String? @unique
  
  locale            String?
  timezone          String?

  // Subscription relations
  subscriptions       UserSubscription[] @relation("UserSubscriptions")
  trainerPackages     PackageTemplate[]  @relation("TrainerPackages")
  clientSubscriptions UserSubscription[] @relation("TrainerSubscriptions")

  // Trainer offer relations
  sentOffers TrainerOffer[] @relation("TrainerOffers")

  // Service delivery relations
  trainerDeliveries ServiceDelivery[] @relation("TrainerDeliveries")
  clientDeliveries  ServiceDelivery[] @relation("ClientDeliveries")

  // Team relations
  teamMemberships TeamMember[]
  sentTeamInvitations TeamInvitation[] @relation("SentTeamInvitations")

  // Location relations
  locations UserLocation[]

  // Terms agreement relations
  termsAgreements UserTermsAgreement[]

  // Messenger relations
  trainerChats  Chat[]    @relation("TrainerChats")
  clientChats   Chat[]    @relation("ClientChats")
  sentMessages  Message[] @relation("SentMessages")

  // Macro tracking relations
  macroTargets     MacroTarget[] @relation("ClientMacroTargets")
  setMacroTargets  MacroTarget[] @relation("TrainerMacroTargets")

  // Personal records
  personalRecords PersonalRecord[]

  // Meal planning relations
  createdNutritionPlans  NutritionPlan[] @relation("TrainerNutritionPlans")
  assignedNutritionPlans NutritionPlan[] @relation("ClientNutritionPlans")
  createdMeals           Meal[]          @relation("CreatedMeals")
  createdIngredients     Ingredient[]    @relation("CreatedIngredients")

  @@index([trainerId])
  @@index([stripeCustomerId])
  @@index([trainerId, role])  // For trainer-client relationship queries
  @@index([googleId])
  @@index([appleId])
}

model UserSession {
  id        String   @id @default(uuid())
  userId    String
  otp       String
  expiresAt DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model UserProfile {
  id                         String            @id @default(uuid())
  userId                     String            @unique
  firstName                  String?
  lastName                   String?
  phone                      String?
  birthday                   DateTime?
  sex                        String?
  avatarUrl                  String?
  activityLevel              String?
  bio                        String?
  createdAt                  DateTime          @default(now())
  updatedAt                  DateTime          @updatedAt
  allergies                  String?
  fitnessLevel               String?
  height                     Float?
  weight                     Float?
  goals                      String[]
  weekStartsOn               Int?              @default(1)
  emailNotifications         Boolean?          @default(true)
  heightUnit                 String?           @default("cm")
  progressUpdates            Boolean?          @default(true)
  pushNotifications          Boolean?          @default(false)
  systemNotifications        Boolean?          @default(true)
  theme                      String?           @default("system")
  timeFormat                 String?           @default("24h")
  weightUnit                 String?           @default("kg")
  workoutReminders           Boolean?          @default(true)
  trainingView               String?           @default("advanced")
  hasCompletedOnboarding     Boolean?          @default(false)
  credentials                String[]          @default([])
  specialization             String[]          @default([])
  successStories             String[]          @default([])
  trainerSince               DateTime?
  bodyMeasures               UserBodyMeasure[]
  bodyProgressLogs           BodyProgressLog[]
  user                       User              @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model UserBodyMeasure {
  id            String      @id @default(uuid())
  userProfileId String
  measuredAt    DateTime    @default(now())
  weight        Float?
  height        Float?
  chest         Float?
  waist         Float?
  hips          Float?
  neck          Float?
  bodyFat       Float?
  notes         String?
  bicepsLeft    Float?
  bicepsRight   Float?
  calfLeft      Float?
  calfRight     Float?
  thighLeft     Float?
  thighRight    Float?
  userProfile   UserProfile @relation(fields: [userProfileId], references: [id], onDelete: Cascade)

  @@index([userProfileId])
}

model BodyProgressLog {
  id              String      @id @default(uuid())
  userProfileId   String
  loggedAt        DateTime    @default(now())
  notes           String?
  image1Url       String?     // Front view
  image2Url       String?     // Side view  
  image3Url       String?     // Back view
  shareWithTrainer Boolean    @default(false)
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  userProfile     UserProfile @relation(fields: [userProfileId], references: [id], onDelete: Cascade)

  @@index([userProfileId])
  @@index([userProfileId, loggedAt])
}

model CoachingRequest {
  id          String   @id @default(uuid())
  senderId    String
  recipientId String
  status      String   @default("PENDING")
  message     String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  recipient   User     @relation("ReceivedRequests", fields: [recipientId], references: [id])
  sender      User     @relation("SentRequests", fields: [senderId], references: [id])

  @@index([senderId])
  @@index([recipientId])
}

model Notification {
  id            String   @id @default(uuid())
  userId        String
  createdBy     String?
  message       String
  type          String
  read          Boolean  @default(false)
  link          String?
  metadata      Json?
  createdAt     DateTime @default(now())
  relatedItemId String?
  creator       User?    @relation("NotificationCreator", fields: [createdBy], references: [id])
  user          User     @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([createdBy])
  @@index([userId, read])
  @@index([userId, createdAt])
}

model PushSubscription {
  id        String   @id @default(uuid())
  userId    String
  endpoint  String   @unique
  p256dh    String
  auth      String
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([endpoint])
}

model MobilePushToken {
  id                       String   @id @default(uuid())
  userId                   String?
  expoPushToken            String   @unique
  platform                 String
  deviceInfo               String?
  pushNotificationsEnabled Boolean  @default(true)
  createdAt                DateTime @default(now())
  updatedAt                DateTime @updatedAt
  lastActiveAt             DateTime @default(now())
  user                     User?    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expoPushToken])
  @@index([pushNotificationsEnabled])
}

model TrainingPlan {
  id            String                     @id @default(uuid())
  title         String
  description   String?
  createdById   String
  isPublic      Boolean                    @default(false)
  isTemplate    Boolean                    @default(false)
  templateId    String?
  completedAt   DateTime?
  createdAt     DateTime                   @default(now())
  updatedAt     DateTime                   @updatedAt
  assignedToId  String?
  isDraft       Boolean                    @default(true)
  active        Boolean                    @default(false)
  endDate       DateTime?
  startDate     DateTime?
  difficulty    String?
  focusTags     String[]
  premium       Boolean                    @default(false)
  targetGoals   String[]
  reviews       Review[]
  assignedTo    User?                      @relation("AssignedPlans", fields: [assignedToId], references: [id])
  createdBy     User                       @relation("CreatedPlans", fields: [createdById], references: [id])
  template      TrainingPlan?              @relation("Template", fields: [templateId], references: [id])
  templates     TrainingPlan[]             @relation("Template")

  weeks         TrainingWeek[]

  @@index([completedAt])
  @@index([assignedToId])
  @@index([assignedToId, active])
  @@index([assignedToId, createdById])
  @@index([createdById])
  @@index([active])
  @@index([templateId])
}

model TrainingWeek {
  id          String        @id @default(uuid())
  planId      String
  weekNumber  Int
  completedAt DateTime?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  description String?
  name        String
  scheduledAt DateTime?
  isExtra     Boolean       @default(false)
  days        TrainingDay[]
  plan        TrainingPlan  @relation(fields: [planId], references: [id], onDelete: Cascade)

  @@index([completedAt])
  @@index([planId])
  @@index([planId, weekNumber])
}

model TrainingDay {
  id          String                @id @default(uuid())
  weekId      String
  dayOfWeek   Int
  completedAt DateTime?
  createdAt   DateTime              @default(now())
  updatedAt   DateTime              @updatedAt
  isRestDay   Boolean               @default(false)
  workoutType String?
  scheduledAt DateTime?
  isExtra     Boolean               @default(false)
  week        TrainingWeek          @relation(fields: [weekId], references: [id], onDelete: Cascade)
  exercises   TrainingExercise[]
  events      WorkoutSessionEvent[]
  personalRecords PersonalRecord[]

  @@index([completedAt])
  @@index([weekId])
  @@index([weekId, dayOfWeek])
}

model TrainingExercise {
  id                     String            @id @default(uuid())
  name                   String
  restSeconds            Int?
  tempo                  String?
  description            String?
  order                  Int
  baseId                 String?
  dayId                  String
  createdAt              DateTime          @default(now())
  updatedAt              DateTime          @updatedAt
  warmupSets             Int?
  completedAt            DateTime?
  additionalInstructions String?
  type                   String?
  isExtra                Boolean           @default(false)
  substitutedById        String?           @unique
  difficulty             String?
  instructions           String[]
  tips                   String[]
  logs                   ExerciseLog[]
  sets                   ExerciseSet[]
  base                   BaseExercise?     @relation(fields: [baseId], references: [id])
  day                    TrainingDay       @relation(fields: [dayId], references: [id], onDelete: Cascade)
  substitutedBy          TrainingExercise? @relation("ReplacedBy", fields: [substitutedById], references: [id])
  substitutes            TrainingExercise? @relation("ReplacedBy")

  @@index([dayId])
  @@index([baseId])
  @@index([completedAt])
  @@index([dayId, completedAt])
  @@index([dayId, order])
  @@index([baseId, dayId])
  @@index([substitutedById])
  @@index([name, completedAt])           // For name filtering + completed check
  @@index([dayId, name, completedAt])    // Combined filter
  @@index([name, dayId])                 // Alternative approach
}

model ExerciseSet {
  id          String           @id @default(uuid())
  order       Int
  reps        Int?
  weight      Float?
  exerciseId  String
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  rpe         Int?
  maxReps     Int?
  minReps     Int?
  completedAt DateTime?
  logId       String?          @unique
  isExtra     Boolean          @default(false)
  exercise    TrainingExercise @relation(fields: [exerciseId], references: [id], onDelete: Cascade)
  log         ExerciseSetLog?  @relation(fields: [logId], references: [id], onDelete: Cascade)

  @@index([exerciseId])
  @@index([completedAt])
  @@index([exerciseId, order])
  @@index([exerciseId, completedAt])
}

model ExerciseLog {
  id          String           @id @default(uuid())
  performedAt DateTime         @default(now())
  notes       String?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  userId      String
  exerciseId  String
  exercise    TrainingExercise @relation(fields: [exerciseId], references: [id], onDelete: Cascade)
  user        User             @relation(fields: [userId], references: [id])

  @@index([exerciseId])
  @@index([userId])
}

model ExerciseSetLog {
  id          String       @id @default(uuid())
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  reps        Int?
  weight      Float?
  rpe         Int?
  ExerciseSet ExerciseSet?
}

model PersonalRecord {
  id            String       @id @default(uuid())
  userId        String
  baseExerciseId String
  dayId         String       // Track which workout day generated this PR
  estimated1RM  Float
  weight        Float
  reps          Int
  achievedAt    DateTime     @default(now())
  createdAt     DateTime     @default(now())
  
  user          User         @relation(fields: [userId], references: [id])
  baseExercise  BaseExercise @relation(fields: [baseExerciseId], references: [id])
  day           TrainingDay  @relation(fields: [dayId], references: [id])
  
  @@unique([userId, baseExerciseId, dayId]) // Prevent duplicate PRs per workout day
  @@index([userId])
  @@index([baseExerciseId])
  @@index([userId, baseExerciseId])
  @@index([userId, baseExerciseId, estimated1RM])
}

model BaseExercise {
  id                        String                     @id @default(uuid())
  name                      String
  description               String?
  videoUrl                  String?
  equipment                 String?
  createdById               String?
  isPublic                  Boolean                    @default(false)
  createdAt                 DateTime                   @default(now())
  updatedAt                 DateTime                   @updatedAt
  additionalInstructions    String?
  type                      String?
  difficulty                String?
  version                   Int                        @default(1)
  isPremium                 Boolean                    @default(false)
  instructions              String[]
  tips                      String[]
  createdBy                 User?                      @relation(fields: [createdById], references: [id])
  substitutes               BaseExerciseSubstitute[]   @relation("OriginalExercise")
  substitutedBy             BaseExerciseSubstitute[]   @relation("SubstituteExercise")
  favouriteWorkoutExercises FavouriteWorkoutExercise[]
  images                    Image[]                    @relation("ExerciseImages")
  trainingExercises         TrainingExercise[]
  muscleGroups              MuscleGroup[]              @relation("ExerciseMuscleGroups")
  secondaryMuscleGroups     MuscleGroup[]              @relation("ExerciseSecondaryMuscleGroups")
  personalRecords           PersonalRecord[]

  @@index([version])
  @@index([difficulty])
  @@index([isPremium])
  @@index([createdById])
}

model Image {
  id         String       @id @default(uuid())
  url        String
  thumbnail  String?      // Optimized thumbnail version ~150px
  medium     String?      // Optimized medium version ~400px  
  large      String?      // Optimized large version ~800px
  order      Int          @default(0)
  entityType String
  entityId   String
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt
  exercise   BaseExercise @relation("ExerciseImages", fields: [entityId], references: [id], map: "exercise_image_fk")

  @@index([entityType, entityId])
  @@index([order])
  @@index([entityId])
  @@index([entityType, entityId, order])
}

model MuscleGroup {
  id                 String              @id @default(uuid())
  name               String              @unique
  alias              String?
  groupSlug          String
  isPrimary          Boolean             @default(true)
  createdAt          DateTime            @default(now())
  categoryId         String
  category           MuscleGroupCategory @relation(fields: [categoryId], references: [id])
  exercises          BaseExercise[]      @relation("ExerciseMuscleGroups")
  secondaryExercises BaseExercise[]      @relation("ExerciseSecondaryMuscleGroups")

  @@index([categoryId])
}

model MuscleGroupCategory {
  id        String        @id @default(uuid())
  name      String        @unique
  slug      String        @unique
  createdAt DateTime      @default(now())
  muscles   MuscleGroup[]
}

model Note {
  id          String   @id @default(uuid())
  text        String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdById String
  relatedToId String?
  metadata    Json?
  createdBy   User     @relation("CreatedNotes", fields: [createdById], references: [id])

  @@index([createdById])
  @@index([relatedToId])
}

model WorkoutSessionEvent {
  id            String      @id @default(cuid())
  dayId         String
  type          String
  timestamp     DateTime    @default(now())
  createdAt     DateTime    @default(now())
  totalDuration Int         @default(0)
  day           TrainingDay @relation(fields: [dayId], references: [id], onDelete: Cascade)

  @@index([dayId])
}

model Review {
  id             String       @id @default(uuid())
  trainingPlanId String
  rating         Int
  comment        String?
  createdById    String
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  isEdited       Boolean      @default(false)
  isHidden       Boolean      @default(false)
  flagged        Boolean      @default(false)
  flagReason     String?
  createdBy      User         @relation(fields: [createdById], references: [id])
  trainingPlan   TrainingPlan @relation(fields: [trainingPlanId], references: [id], onDelete: Cascade)

  @@index([trainingPlanId])
  @@index([createdById])
  @@index([isHidden])
  @@index([flagged])
}

model BaseExerciseSubstitute {
  id           String       @id @default(uuid())
  originalId   String
  substituteId String
  reason       String?
  createdAt    DateTime     @default(now())
  original     BaseExercise @relation("OriginalExercise", fields: [originalId], references: [id], onDelete: Cascade)
  substitute   BaseExercise @relation("SubstituteExercise", fields: [substituteId], references: [id], onDelete: Cascade)

  @@unique([originalId, substituteId])
  @@index([originalId])
  @@index([substituteId])
}
model FavouriteWorkout {
  id          String                     @id @default(uuid())
  title       String
  description String?
  createdById String
  createdAt   DateTime                   @default(now())
  updatedAt   DateTime                   @updatedAt
  createdBy   User                       @relation("CreatedFavouriteWorkouts", fields: [createdById], references: [id])
  exercises   FavouriteWorkoutExercise[]

  @@index([createdById])
}

model FavouriteWorkoutExercise {
  id                     String                @id @default(uuid())
  name                   String
  order                  Int
  baseId                 String?
  favouriteWorkoutId     String
  restSeconds            Int?
  additionalInstructions String?
  description            String?
  instructions           String[]
  tips                   String[]
  difficulty             String?
  base                   BaseExercise?         @relation(fields: [baseId], references: [id])
  favouriteWorkout       FavouriteWorkout      @relation(fields: [favouriteWorkoutId], references: [id], onDelete: Cascade)
  sets                   FavouriteWorkoutSet[]

  @@index([favouriteWorkoutId])
  @@index([baseId])
}

model FavouriteWorkoutSet {
  id         String                   @id @default(uuid())
  order      Int
  reps       Int?
  minReps    Int?
  maxReps    Int?
  weight     Float?
  rpe        Int?
  exerciseId String
  exercise   FavouriteWorkoutExercise @relation(fields: [exerciseId], references: [id], onDelete: Cascade)

  @@index([exerciseId])
}

// Subscription System Models

model PackageTemplate {
  id          String               @id @default(uuid())
  name        String // "Training + Coaching", "Full Combo", etc.
  description String?
  duration    SubscriptionDuration
  isActive    Boolean              @default(true)

  // Stripe integration
  stripeProductId String? // Maps to Stripe product
  stripePriceId   String? // Single price ID (Stripe handles multi-currency)

  // Who can offer this package (null = general premium, specific = trainer package)
  trainerId String?
  trainer   User?   @relation("TrainerPackages", fields: [trainerId], references: [id])

  // Stripe metadata for business logic (commission rates, service types, etc.)
  metadata Json?

  // Purchased subscriptions
  subscriptions UserSubscription[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([trainerId])
  @@index([isActive])
  @@index([duration])
  @@index([stripeProductId])
  @@index([stripePriceId])
  @@index([metadata], type: Gin)
}

model UserSubscription {
  id        String  @id @default(uuid())
  userId    String
  packageId String
  trainerId String? // null for premium, specific for trainer packages

  status    SubscriptionStatus @default(ACTIVE)
  startDate DateTime
  endDate   DateTime

  // Trial management (14 days)
  trialStart    DateTime?
  trialEnd      DateTime?
  isTrialActive Boolean   @default(false)

  // Grace period management (3 days after failed payment)
  gracePeriodEnd  DateTime?
  isInGracePeriod Boolean   @default(false)

  // Payment retry tracking
  failedPaymentRetries Int       @default(0)
  lastPaymentAttempt   DateTime?

  // Stripe integration
  stripeSubscriptionId String?
  stripePriceId        String?

  // Mock payment tracking (until Stripe integration)
  mockPaymentStatus String? @default("COMPLETED") // PENDING, COMPLETED, FAILED
  mockTransactionId String? // Internal transaction ID

  user    User            @relation("UserSubscriptions", fields: [userId], references: [id])
  package PackageTemplate @relation(fields: [packageId], references: [id])
  trainer User?           @relation("TrainerSubscriptions", fields: [trainerId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([trainerId])
  @@index([status])
  @@index([endDate])
  @@index([startDate])
  @@index([trialEnd])
  @@index([gracePeriodEnd])
  @@index([isTrialActive])
  @@index([isInGracePeriod])
}

// Enums for Subscription System

enum ServiceType {
  WORKOUT_PLAN
  MEAL_PLAN
  COACHING_COMPLETE
  IN_PERSON_MEETING
  PREMIUM_ACCESS
}

enum SubscriptionDuration {
  MONTHLY
  YEARLY
}

enum SubscriptionStatus {
  ACTIVE
  EXPIRED
  CANCELLED
  PENDING
}

enum Currency {
  NOK
  EUR
  USD
}

model TrainerOffer {
  id              String  @id @default(uuid())
  token           String  @unique // Unique token for secure offer links
  trainerId       String
  clientEmail     String
  personalMessage String?
  status          String  @default("PENDING") // PENDING, PAID, EXPIRED, CANCELLED

  // Stripe integration - links to checkout session when paid
  stripeCheckoutSessionId String? @unique
  stripePaymentIntentId   String? @unique

  // Package summary for display (JSON array of {packageId, quantity, name})
  packageSummary Json? // Lightweight summary for UI, full data in Stripe

  // Timestamps
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  expiresAt   DateTime // Offers expire after 24 hours
  completedAt DateTime?

  // Relations
  trainer User @relation("TrainerOffers", fields: [trainerId], references: [id])

  @@index([token])
  @@index([trainerId])
  @@index([clientEmail])
  @@index([status])
  @@index([expiresAt])
  @@index([createdAt])
  @@index([stripeCheckoutSessionId])
  @@index([stripePaymentIntentId])
}

// Service delivery tracking - what trainers need to deliver to clients
model ServiceDelivery {
  id                    String      @id @default(uuid())
  stripePaymentIntentId String // Links to Stripe payment for payment verification
  trainerId             String
  clientId              String
  serviceType           ServiceType
  packageName           String
  quantity              Int         @default(1)

  // Delivery status and progress
  status        DeliveryStatus @default(PENDING)
  deliveredAt   DateTime?
  deliveryNotes String?

  // Optional metadata for specific delivery details
  metadata Json? // Can store meeting details, plan IDs, etc.

  // Relations
  trainer User          @relation("TrainerDeliveries", fields: [trainerId], references: [id])
  client  User          @relation("ClientDeliveries", fields: [clientId], references: [id])
  tasks   ServiceTask[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([trainerId])
  @@index([clientId])
  @@index([stripePaymentIntentId])
  @@index([status])
  @@index([serviceType])
  @@index([createdAt])
}

// Service task for individual deliverables within a service delivery
model ServiceTask {
  id                 String    @id @default(uuid())
  serviceDeliveryId  String
  templateId         String
  title              String
  taskType           String
  status             String    @default("PENDING")
  order              Int       @default(0)
  isRequired         Boolean   @default(true)
  completedAt        DateTime?
  notes              String?
  requiresScheduling Boolean   @default(false)
  scheduledAt        DateTime?
  estimatedDuration  Int?
  isRecurring        Boolean   @default(false)
  intervalDays       Int?
  recurrenceCount    Int?
  metadata           Json?

  serviceDelivery ServiceDelivery @relation(fields: [serviceDeliveryId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([serviceDeliveryId])
  @@index([status])
  @@index([templateId])
  @@index([scheduledAt])
}

// Delivery status enum
enum DeliveryStatus {
  PENDING // Service purchased but not yet delivered
  IN_PROGRESS // Trainer has started working on delivery
  COMPLETED // Service fully delivered to client
  CANCELLED // Service delivery cancelled/refunded
}

// Location for teams and users
model Location {
  id          String @id @default(uuid())
  city        String
  country     String
  countryCode String @db.Char(2)
  
  teams TeamLocation[]
  users UserLocation[]
  
  @@unique([city, country])
  @@index([city])
}

// Team model
model Team {
  id        String   @id @default(uuid())
  name      String
  
  // Stripe Connect integration for team-based payouts
  stripeConnectedAccountId String?  @unique  // For receiving team revenue share
  stripeCustomerId         String?  @unique  // For team-level purchases (if needed)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  locations   TeamLocation[]
  members     TeamMember[]
  invitations TeamInvitation[]
  
  // Meal planning relations
  meals Meal[]
}

// Team membership
model TeamMember {
  id     String   @id @default(uuid())
  teamId String
  userId String
  role   String   @default("MEMBER") // ADMIN, MEMBER
  joinedAt DateTime @default(now())
  
  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([teamId, userId])
  @@index([teamId])
  @@index([userId])
}

// Team invitations
model TeamInvitation {
  id           String   @id @default(uuid())
  teamId       String
  invitedEmail String
  invitedById  String
  status       String   @default("PENDING") // PENDING, ACCEPTED, REJECTED
  createdAt    DateTime @default(now())
  
  team      Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  invitedBy User @relation("SentTeamInvitations", fields: [invitedById], references: [id])
  
  @@unique([teamId, invitedEmail])
  @@index([teamId])
  @@index([invitedEmail])
  @@index([invitedById])
}

// User locations (many-to-many)
model UserLocation {
  id         String   @id @default(uuid())
  userId     String
  locationId String
  createdAt  DateTime @default(now())
  
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  location Location @relation(fields: [locationId], references: [id])
  
  @@unique([userId, locationId])
  @@index([userId])
  @@index([locationId])
}

// Team locations (many-to-many)
model TeamLocation {
  id         String   @id @default(uuid())
  teamId     String
  locationId String
  createdAt  DateTime @default(now())
  
  team     Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  location Location @relation(fields: [locationId], references: [id])
  
  @@unique([teamId, locationId])
  @@index([teamId])
  @@index([locationId])
}

// Simple terms agreement tracking
model UserTermsAgreement {
  id        String   @id @default(uuid())
  userId    String
  version   String   // e.g., "v1.0", "2024-12-01"
  offerId   String?  // Optional: link to specific offer
  agreedAt  DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([version])
  @@index([agreedAt])
}

// Messenger System Models

model Chat {
  id          String    @id @default(uuid())
  trainerId   String
  clientId    String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  trainer     User      @relation("TrainerChats", fields: [trainerId], references: [id])
  client      User      @relation("ClientChats", fields: [clientId], references: [id])
  messages    Message[]
  
  @@unique([trainerId, clientId])
  @@index([trainerId])
  @@index([clientId])
}

model Message {
  id          String    @id @default(uuid())
  chatId      String
  senderId    String
  content     String
  imageUrl    String?   // For future image support
  isEdited    Boolean   @default(false)
  isDeleted   Boolean   @default(false)
  readAt      DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  chat        Chat      @relation(fields: [chatId], references: [id], onDelete: Cascade)
  sender      User      @relation("SentMessages", fields: [senderId], references: [id])
  
  @@index([chatId])
  @@index([senderId])
  @@index([createdAt])
  @@index([chatId, senderId, readAt])  // For unread message queries
  @@index([chatId, createdAt(sort: Desc)])  // For message ordering
  @@index([senderId, readAt])  // For user's unread messages across all chats
}

model MacroTarget {
  id        String   @id @default(uuid())
  clientId  String   @unique // One macro target per client
  trainerId String   // Who set these targets
  
  // Daily macro targets
  calories  Int?     // Daily calorie target
  protein   Float?   // Daily protein target (grams)
  carbs     Float?   // Daily carbohydrate target (grams)  
  fat       Float?   // Daily fat target (grams)
  
  notes     String?  // Optional notes from trainer
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  client    User     @relation("ClientMacroTargets", fields: [clientId], references: [id], onDelete: Cascade)
  trainer   User     @relation("TrainerMacroTargets", fields: [trainerId], references: [id])
  
  @@index([clientId])
  @@index([trainerId])
}

// Meal Planning System Models

model NutritionPlan {
  id                  String               @id @default(uuid())
  name                String
  description         String?
  trainerId           String
  clientId            String
  isSharedWithClient  Boolean              @default(false)
  sharedAt            DateTime?
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt

  trainer             User                 @relation("TrainerNutritionPlans", fields: [trainerId], references: [id], onDelete: Cascade)
  client              User                 @relation("ClientNutritionPlans", fields: [clientId], references: [id], onDelete: Cascade)
  days                NutritionPlanDay[]

  @@index([trainerId, clientId])
  @@index([trainerId, isSharedWithClient])
  @@index([clientId, isSharedWithClient])
  @@index([trainerId, clientId, isSharedWithClient])
  @@index([sharedAt])
  @@index([updatedAt])
}

model NutritionPlanDay {
  id               String               @id @default(uuid())
  nutritionPlanId  String
  dayNumber        Int
  name             String
  createdAt        DateTime             @default(now())

  nutritionPlan    NutritionPlan        @relation(fields: [nutritionPlanId], references: [id], onDelete: Cascade)
  meals            NutritionPlanMeal[]

  @@unique([nutritionPlanId, dayNumber])
  @@index([nutritionPlanId, dayNumber])
}

model Meal {
  id              String               @id @default(uuid())
  name            String
  description     String?
  instructions    String[]             @default([])
  preparationTime Int?                 // minutes
  cookingTime     Int?                 // minutes
  servings        Int?
  createdById     String
  teamId          String?
  createdAt       DateTime             @default(now())
  updatedAt       DateTime             @updatedAt

  createdBy       User                 @relation("CreatedMeals", fields: [createdById], references: [id])
  team            Team?                @relation(fields: [teamId], references: [id], onDelete: SetNull)
  ingredients     MealIngredient[]
  planMeals       NutritionPlanMeal[]

  @@index([teamId, createdAt])
  @@index([teamId, name])
  @@index([createdById, createdAt])
  @@index([teamId, name, createdAt])
}

model Ingredient {
  id              String           @id @default(uuid())
  name            String
  proteinPer100g  Float            @default(0)
  carbsPer100g    Float            @default(0)
  fatPer100g      Float            @default(0)
  caloriesPer100g Float            @default(0)
  createdById     String
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  createdBy       User             @relation("CreatedIngredients", fields: [createdById], references: [id])
  mealIngredients MealIngredient[]

  @@index([createdById, createdAt])
  @@index([name])
}

model MealIngredient {
  id           String     @id @default(uuid())
  mealId       String
  ingredientId String
  grams        Float
  orderIndex   Int        @default(0)
  createdAt    DateTime   @default(now())

  meal         Meal       @relation(fields: [mealId], references: [id], onDelete: Cascade)
  ingredient   Ingredient @relation(fields: [ingredientId], references: [id], onDelete: Cascade)
  planOverrides NutritionPlanMealIngredient[]

  @@unique([mealId, ingredientId])
  @@index([mealId, orderIndex])
  @@index([ingredientId])
  @@index([mealId])
}

model NutritionPlanMeal {
  id                   String           @id @default(uuid())
  nutritionPlanDayId   String
  mealId               String
  orderIndex           Int              @default(0)
  createdAt            DateTime         @default(now())

  nutritionPlanDay     NutritionPlanDay @relation(fields: [nutritionPlanDayId], references: [id], onDelete: Cascade)
  meal                 Meal             @relation(fields: [mealId], references: [id], onDelete: Cascade)
  ingredientOverrides  NutritionPlanMealIngredient[]

  @@index([nutritionPlanDayId, orderIndex])
  @@index([mealId])
  @@index([nutritionPlanDayId])
}

model NutritionPlanMealIngredient {
  id                   String           @id @default(uuid())
  nutritionPlanMealId  String
  mealIngredientId     String
  grams                Float
  createdAt            DateTime         @default(now())

  nutritionPlanMeal    NutritionPlanMeal @relation(fields: [nutritionPlanMealId], references: [id], onDelete: Cascade)
  mealIngredient       MealIngredient   @relation(fields: [mealIngredientId], references: [id], onDelete: Cascade)

  @@unique([nutritionPlanMealId, mealIngredientId])
  @@index([nutritionPlanMealId])
  @@index([mealIngredientId])
}
