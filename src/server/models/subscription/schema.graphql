# SIMPLIFIED Subscription System GraphQL Schema
# This replaces the complex schema with Stripe-as-source-of-truth approach

enum ServiceType {
  workout_plan
  meal_plan
  coaching_complete
  in_person_meeting
  premium_access
}

enum SubscriptionDuration {
  MONTHLY
  YEARLY
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED_ACTIVE
  EXPIRED
  CANCELLED
  PENDING
}

enum DeliveryStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

# Simplified user subscription status - focuses on what user can access
type UserSubscriptionStatus {
  hasPremium: Boolean!
  trainerId: ID
  canAccessPremiumTrainingPlans: Boolean!
  canAccessPremiumExercises: Boolean!
  canAccessMealPlans: Boolean!
  subscriptionEndDate: String # When current subscription ends
  isInGracePeriod: Boolean! # Stripe handles grace periods
  trainingPlanLimit: Int!
  favouriteWorkoutLimit: Int!
  favouriteFolderLimit: Int!
}

# UserSubscription type is defined in user-subscription/schema.graphql

# Package templates - simplified without services relation
type PackageTemplate {
  id: ID!
  name: String!
  description: String
  duration: SubscriptionDuration!
  isActive: Boolean!

  # Stripe integration
  stripeProductId: String
  stripeLookupKey: String

  # Trainer assignment
  trainerId: ID
  trainer: User

  # Service info stored in metadata instead of separate table
  serviceType: ServiceType # Computed from metadata
  createdAt: String!
  updatedAt: String!
}

# Service delivery tracking (replaces complex usage tracking)
type ServiceDelivery {
  id: ID!
  trainerId: ID!
  clientId: ID!
  serviceType: ServiceType
  packageName: String!
  quantity: Int!
  status: DeliveryStatus!

  deliveredAt: String
  deliveryNotes: String

  # Computed deadline fields (based on createdAt + serviceType config)
  dueDate: String!
  isOverdue: Boolean!
  daysUntilDue: Int!
  deliverableLabel: String!

  # Task progress
  tasks: [ServiceTask!]!
  taskProgress: Int! # Percentage (0-100)
  completedTaskCount: Int!
  totalTaskCount: Int!

  # Relations
  trainer: User!
  client: User!

  createdAt: String!
  updatedAt: String!
}

# Admin types for subscription management
type UserWithSubscription {
  id: ID!
  email: String!
  name: String
  role: String!
  hasActiveSubscription: Boolean!
  subscription: UserSubscription
  createdAt: String!
}

type UsersWithSubscriptionsResult {
  users: [UserWithSubscription!]!
  totalCount: Int!
}

type SubscriptionStats {
  totalUsers: Int!
  usersWithActiveSubscriptions: Int!
  usersWithExpiredSubscriptions: Int!
  usersWithoutSubscriptions: Int!
  totalLifetimeSubscriptions: Int!
}

# SIMPLIFIED QUERIES - Focus on essentials only
type Query {
  # Essential subscription checks

  # Admin subscription management
  getAllUsersWithSubscriptions(
    limit: Int
    offset: Int
    searchQuery: String
  ): UsersWithSubscriptionsResult!
  getSubscriptionStats: SubscriptionStats!
  getMySubscriptionStatus: UserSubscriptionStatus!
  checkPremiumAccess: Boolean!

  # Package management
  getActivePackageTemplates(trainerId: ID): [PackageTemplate!]!
  getPackageTemplate(id: ID!): PackageTemplate

  # Service delivery (replaces complex usage tracking)
  getMyServiceDeliveries(statuses: [DeliveryStatus!]): [ServiceDelivery!]!
  getTrainerDeliveries(
    trainerId: ID!
    statuses: [DeliveryStatus!]
  ): [ServiceDelivery!]!

  # Basic subscription info (simplified)
  getMySubscriptions: [UserSubscription!]!

  # Subscription freeze (Premium Yearly only)
  getFreezeEligibility: FreezeEligibility!
}

type Mutation {
  # Service delivery management (replaces usage tracking)
  updateServiceDelivery(
    deliveryId: ID!
    status: DeliveryStatus!
    notes: String
  ): ServiceDelivery!

  # Coaching subscription management
  pauseClientCoachingSubscription(clientId: ID!): PauseCoachingResult!
  resumeClientCoachingSubscription(clientId: ID!): ResumeCoachingResult!
  cancelClientCoachingSubscription(
    clientId: ID!
    cancelAt: String!
  ): CancelCoachingResult!
  undoCancelClientCoachingSubscription(clientId: ID!): UndoCancelCoachingResult!

  # Admin subscription management
  giveLifetimePremium(userId: ID!): UserSubscription!
  removeUserSubscription(userId: ID!): Boolean!

  # Subscription freeze (Premium Yearly only)
  pauseMySubscription(days: Int!): FreezeResult!
  resumeMySubscription: FreezeResult!
}

type PauseCoachingResult {
  success: Boolean!
  message: String!
  pausedUntil: String
  subscription: UserSubscription
}

type ResumeCoachingResult {
  success: Boolean!
  message: String!
  subscription: UserSubscription
}

type CancelCoachingResult {
  success: Boolean!
  message: String!
  cancelAt: String # The date subscription will end
  subscription: UserSubscription
}

type UndoCancelCoachingResult {
  success: Boolean!
  message: String!
  subscription: UserSubscription
}

# Subscription Freeze (Premium Yearly only)
type FreezeEligibility {
  canFreeze: Boolean!
  reason: String
  daysRemaining: Int!
  minDays: Int!
  maxDays: Int!
  availableFrom: String
  isPaused: Boolean!
  pauseEndsAt: String
}

type FreezeResult {
  success: Boolean!
  message: String
  pauseEndsAt: String
}
